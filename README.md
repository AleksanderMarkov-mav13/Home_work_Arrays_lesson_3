**Задача 1**

По поводу успешного прохождения двумерных массивов собирается банкет, организуется стол на 12 персон. Есть два VIP-места, они рядом во главе стола. Стол протяжён в длину, места расположены в два ряда. Каждый пришедший должен быть «упакован» соответствующим образом. Во-первых, столовые приборы: по три на каждого человека (вилка, ложка, нож) и одна маленькая дополнительная ложечка для VIP-персон (для десерта). Во-вторых, тарелки: каждому по две (для первого и второго блюда) и ещё одна тарелка для VIP-персон (для десерта). В-третьих, стулья: минимум один для каждого гостя. Заведите соответствующие двумерные массивы для количества приборов, посуды и стульев и проинициализируйте их.
Но это ещё не всё. На банкете после инициализации происходят некоторые события. Пришедшая на пятое место первого ряда дама привела с собой ребёнка, и поэтому на данное место был приставлен ещё один стул. С третьего места во втором ряду в неизвестном направлении была украдена ложка. Одна из VIP-персон (любая) поделилась своей ложкой с тем, кто остался без ложки, и стала есть суп десертной. За ненадобностью официант забрал у VIP-гостя одну десертную тарелку, ведь есть десерт ложкой, которая уже побывала уже в супе, неприлично. Больше без происшествий, однако эти события на банкете надо отразить в инициализированных ранее массивах.

Советы и рекомендации
• Все действия в задаче оформляются в виде выражений внутри исходного кода. Текстовый интерфейс для задачи делать необязательно.
• Необходимо объявить несколько двумерных массивов (по типам приборов).

*Это просто создать три двухмерных массива и произвести простые действия с отдельными их элементами. Просто что-бы попробовать...*

**Задача 2**
Старая добрая игра на страницах всех школьных тетрадей. Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char. Участвуют два игрока, они ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ — X или O (буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика, он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено, то объявляется ничья. Для простоты не будем рассматривать диагональные совпадения — только строго вертикальные и строго горизонтальные.
Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения пробела кавычки одинарные и в одну сторону). Это можно сделать сразу при объявлении либо с помощью вложенного цикла. На каждом ходе при занятой клетке или при неверных координатах этой клетки должно быть выведено сообщение, и игрок должен указать координаты клетки повторно. После каждого хода надо выводить в консоль текущее состояние всего игрового поля для наглядности.

*Оказалось - ничего сложного, просто скрупулезно все описал. Добавил и проверку выигрыша по диагонали, правда уже без использования цикла - там всего 3 переменные, т.е. и по 3 условия в 2 проверках - что там описывать ?*

**Задача 3**
Требуется реализовать небольшую программу для сравнения двух двумерных матриц размером 4 × 4 на предмет их полного равенства. Если матрицы равны друг другу, необходимо взять одну из матриц и привести её к диагональному виду. Программа принимает на вход две целочисленные матрицы A и B, которые вводятся с помощью std::cin, и сравнивает их на предмет полного равенства. Если матрицы равны, то об этом сообщается в стандартном выводе. Алгоритм должен быть по возможности оптимальным и не проводить лишних операций. Если матрицы не равны, выводится соответствующее сообщение и выполнение программы прекращается. Если матрицы равны, то из них выбирается одна и преобразуется в диагональную. Конвертация в диагональную форму делается путём простейшего зануления всех элементов, лежащих вне главной диагонали. Напомню, что диагональная матрица — это такая матрица, у которой все элементы вне диагонали равны нулю. Диагональ матрицы, в свою очередь, — это все элементы, расположенные по диагонали от первого элемента первой строки до последнего элемента последней строки. Итоговую диагональную матрицу можно расположить на месте прежней матрицы, не используя дополнительных переменных. Результат преобразования требуется вывести в консоль для проверки. Ищите именно оптимальное решение, оно довольно простое.

Советы и рекомендации
• Чтобы не производить лишних вычислений, стоит при первом же расхождении значений в соответствующих ячейках завершить алгоритм.
• Если хотя бы один элемент матриц не совпадает, можно сразу останавливать проверку.
• Чтобы в результате получить диагональную матрицу, достаточно пройти по каждому элементу массива и занулить его, если строка не равна столбцу.
• Достаточно привести матрицу к диагональному виду. Делать алгоритмическое преобразование не нужно.
• Сравнение матриц и приведение матрицы к диагональному виду лучше оформить в виде отдельных функций.

**Задача 4**
Реализуйте частный случай умножения матрицы на матрицу, а именно умножение вектора на матрицу. Эта операция распространена в компьютерной индустрии в целом и в компьютерной графике в частности, поэтому это будет хорошим упражнением.
Итак, у нас есть четырёхкомпонентный вектор b, представленный с помощью массива, и матрица a размером 4 × 4, представленная в виде двумерного массива. Их произведением будет новый четырёхэлементный вектор c. Его компоненты будут суммой произведений элемента вектора b на строку матрицы a. Индекс столбца при этом равен индексу соответствующей компоненты вектора b, который мы и рассчитываем.
Все входные данные, матрица a и вектор b вносятся из пользовательского ввода. Итоговый вектор c надо вывести в консоль (std::cout). Тип данных элементов — всегда float. Желательно реализовать этот алгоритм с помощью вложенного цикла на умножение колонки.

Файл 3_4_Multiplication_matrix_test.cpp создан для удобства тестирования - в нем массивы заданы в самой программе - что-бы не вводить с клавиатуры

Для оценки домашней работы прошу использовать файл 3_4_Multiplication_matrix.cpp

**Задача 5**

Пупырка
После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. Всего в пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый, либо нет, то есть true или false (тип массива — bool). Для начала требуется реализовать отдельную функцию инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true.
Программа заключается в последовательном лопании целых регионов пузырьков. Перед каждым таким лопанием надо показывать пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию. 
Итак, как выглядит само лопание. Пользователь вводит две координаты: начала региона и конца региона. Процедура лопания пузырей должна быть реализована с помощью отдельной функции, все аргументы должны проверяться на валидность, что они в в рамках диапазона возможных значений, иначе должна быть выведена ошибка. После лопания каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться сообщение “Pop!”.
Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает выполнение. Вы можете подсчитать окончание в самой функции по отображению пузырьков плёнки, так как функция выполняется после каждого лопания.

**Задача 6**

Есть двумерный массив целых чисел размером 5 на 5 элементов. Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации. Элементы должны быть инициализированы не последовательно, а змейкой: в конце каждой строки мы должны не переходить к первому элементу следующей строки, а начать наоборот, с последнего элемента и так далее. 
В конечном отображении массива числа должны быть упорядочены по возрастанию, но змеевидно от строке к строке. Сама же последовательность чисел — это простое линейное возрастание от 0 до 24, для её учёта можно завести отдельную переменную.
Попытайтесь решить эту задачу используя минимальное количество временных переменных и без условных переходов if. 

**Задача 7**

